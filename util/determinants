#!/usr/bin/env python3
"""
This is not the way to do it.
"""

__author__ = "Peter Kleiweg"
__version__ = "0.1"
__date__ = "2010/07/14"

#| imports

import cgitb; cgitb.enable(format="text")

import os, re ,math, sys

import u.setChar as setChar

#| globals

clufile = 'clgroups.txt'
target = int(sys.argv[1])
datafile = sys.argv[2]

minvar = 2

#| functions

def _esc(m):
    return '_{}_'.format(ord(m.group()))

def _escape(s):
    if not s:
        return '__'
    return re.sub(r'[^-+a-zA-Z0-9]', _esc, s)

def _unquote(s):
    s = s.strip()
    if len(s) < 2:
        return s
    if s[0] != '"' or s[-1] != '"':
        return s
    return re.sub(r'\\(.)', r'\1', s[1:-1]).strip()


#| main

partition = set()
nPlaceIn = 0
nPlaceOut = 0
fp = open(clufile, 'rt', encoding='iso-8859-1')
for line in fp:
    a, b = line.split(None, 1)
    if int(a) == target:
        partition.add(_unquote(b))
        nPlaceIn += 1
    else:
        nPlaceOut += 1
fp.close()
RelSize = nPlaceIn / (nPlaceIn + nPlaceOut)

fp = open(datafile, 'rb')
lines = fp.readlines()
fp.close()

encoding = 'iso-8859-1'
ignore = re.compile('[^ a-zA-Z0-9]+')
subst = {}
datapat = {}
lbl = ''
for line in lines:
    if line.startswith(b'%utf8'):
        encoding = 'utf-8'
        ign = setChar.Vowel.union(setChar.Consonant).union(setChar.Semivowel)
        first = ''
        if os.access('accentscurrent.txt', os.F_OK):
            fp = open('accentscurrent.txt', 'rt')
            for line in fp:
                c = '{:c}'.format(int(line))
                if c == '-':
                    first = '-'
                elif c == '[' or c == ']' or c == '\\':
                    ign.add('\\' + c)
                else:
                    ign.add(c)
            fp.close()
        ignore = re.compile('[^' + first + ''.join(ign) + ']+')
    elif line[:1] == b':':
        lbl = line.decode('iso-8859-1')[1:].strip()
    elif line[:1] == b'-':
        wrd = line.decode(encoding)[1:].strip()
        pat = ignore.sub('', wrd).strip()
        if not pat in datapat:
            datapat[pat] = set()
            subst[pat] = set()
        datapat[pat].add(lbl)
        subst[pat].add(_escape(wrd))

variants = []
for variant in datapat:
    outplaces = set()
    inplaces = set()
    for place in datapat[variant]:
        if place in partition:
            inplaces.add(place)
        else:
            outplaces.add(place)
    i = len(inplaces)
    o = len(outplaces)
    if i + o < minvar:
        continue
    RelOcc = i / (i + o)
    Distinct = (RelOcc - RelSize) / (1.0 - RelSize)
    Repres = i / nPlaceIn
    if Distinct > 0.0:
        Import = (Repres + Distinct) / 2.0
    else:
        Import = 0
    variants.append((-Import, -Distinct, -Repres, variant, i + o, inplaces, outplaces))

Importance = 0
allOutPlaces = set()
allInPlaces = set()
rejected = set()
for Imp, Dis, Rep, s, n, ip, op in sorted(variants):
    inplaces = allInPlaces.union(ip)
    outplaces = allOutPlaces.union(op)
    i = len(inplaces)
    o = len(outplaces)
    RelOcc = i / (i + o)
    Distinct = (RelOcc - RelSize) / (1.0 - RelSize)
    Repres = i / nPlaceIn
    if Distinct > 0.0:
        Import = (Repres + Distinct) / 2.0
    else:
        Import = 0
    if Import > Importance and Dis > 0.0:
        Importance = Import
        sys.stdout.write('{:.3f} {:.3f} {:.3f} {} ({}) [ {} ]\n'.format(-Imp, -Dis, -Rep, _escape(s), n, ' | '.join(sorted(subst[s]))))
        allInPlaces = inplaces
        allOutPlaces = outplaces
    else:
        rejected.add(s)

for line in sorted(rejected):
    sys.stdout.write('[' + _escape(line) + ']\n')

i = len(allInPlaces)
o = len(allOutPlaces)

if i + o == 0:
    sys.stdout.write('\n0.000 0.000 0.000 0\n')
    sys.exit()

RelOcc = i / (i + o)
Distinct = (RelOcc - RelSize) / (1.0 - RelSize)
Repres = i / nPlaceIn
Distinct > 0:
    Importance = (Repres + Distinct) / 2.0
else:
    Importance = 0

sys.stdout.write('\n{:.3f} {:.3f} {:.3f} {:5d}\n'.format(Importance, Distinct, Repres, i + o))
